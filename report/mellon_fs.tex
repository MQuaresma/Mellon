\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}
\usepackage[a4paper, total={7in, 9in}]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{fancyvrb}

\newcommand{\question}[1]{
    {\large \textbf{Q: #1}}
    \\
}

\newcommand{\titleRule}{
    \rule{\linewidth}{0.5mm} \\ [0.25cm]
}

\begin{document}

\begin{titlepage}
    \center
    \begin{figure}[H]
        \centering
        \includegraphics[width=4cm]{Pictures/UM_EENG.jpg}
    \end{figure}
    \textsc{\LARGE Universidade do Minho} \\ [1.5cm]
    \textsc{\Large Mestrado Integrado em Engenharia Informática} \\ [0.5cm]
    \textsc{\large Tecnologia de Segurança} \\ [0.5cm]

    \titleRule
    {\huge \bfseries MellonFS - Userspace Filesystem}
    \titleRule

    Miguel Miranda Quaresma A77049 \\[0.25cm]

    \today
\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Introdução}
A utilização de sistemas de computação tem vindo a tornar-se um requisito cada vez mais fundamental nas mais diversas áreas da sociedade. Consequentemente, é 
necessário garantir que os mesmos representam uma plataforma de trabalho segura que não comprometa os serviços que neles dependem. Um aspetos fundamentais para 
atingir esse objetivo passa por controlar o acesso de diversos utilizadores aos ficheiros presentes nos sistemas, sendo necessário desenvolver mecanismos que 
sejam não só seguros e convenientes mas também adequados às necessidades apresentadas.
O sistema de permissões Unix apresenta portanto uma clara desvantagem: a sua simplicicade torna-o pouco flexível e difícil de gerir para um utilizador "normal". 
Para colmatar este facto torna-se útil desenvolver sistemas de ficheiros a um nível mais elevado que recorram a estruturas de controlo de acesso complexas, 
permitindo assim implementar um sistema de controlo eficaz. O presente trabalho apresenta um implementação primitiva de um mecanismo de controlo de acesso com 
recurso à biblioteca libfuse que visa autenticar utilizadores com recurso a um código aleatório.

\section{libfuse}
Como foi referido o presente projeto recorre à biblioteca \textit{libfuse} que é uma API para o módulo \textbf{FUSE} do kernel Linux que permite o 
desenvolvimento de sistemas de ficheiros em \textit{userspace}.

\section{MellonFS}
O sistema MellonFS apresenta uma arquitetura constituída por dois módulos distintos: uma \textit{web interface} responsável por autenticar o utilizador cada 
vez que este recebe um código no seu endereço de correio eletrónico e o sistema de ficheiros em si, desenvolvido em C com recurso à biblioteca libfuse, 
responsável por gerar o código de autenticação e notificar o utilizador. Cada vez que é invocada a \textit{system call} \texttt{open}, é gerado, aleatoriamente, 
um \textit{array} de 4 bytes que após ser enviado ao utilizador, deve ser introduzido pelo mesmo num período de tempo inferior a 45s para que a autenticação 
tenha sucesso.

\subsection{Implementação}
\subsubsection{Web Frontend}
A \textit{webfronted} foi desenvolvido com recurso à linguagem Python e à framework \textit{Flask}.
É esta a componente que deve ser invocada para iniciar o \textit{daemon} do sistema de ficheiros e autenticar o utilizador cada vez que este pretende abrir um 
ficheiro. Antes de inicializar o \textit{daemon}, o \textit{frontend} requisita o \textit{username} ao utilizador, que permitirá determinar se este está 
autorizado a alterar ficheiros no sistema de desenvolvido. De seguida este valor é passado ao \textit{daemon} como argumento de linha de comandos:
\begin{Verbatim}
mellon_fs = Popen(['./bin/mellon', '../MountPoint', '--user='+uname, '--email='+email])
\end{Verbatim}
Qualquer comunicação subsequente entre os dois processos é efetuada com recurso a um \textit{named pipe} disponibilizado por sistemas Unix: 
\begin{Verbatim}
mellon_fifo = open("mellon_fifo", "w")
...
mellon_fifo.write(code[:5])
mellon_fifo.flush()
\end{Verbatim}
A \textit{web frontend} foi desenvolvido com recurso à biblioteca \textit{Flask} e possui duas \textit{views} uma para identificação inicial e outra para 
autenticação \textit{on demand}.

\subsubsection{File system daemon}
O sistema de ficheiros em si foi desenvolvido em C e é responsável por implementar as funções que são invocadas consoante as \textit{system calls} envolvidas 
nas operações em ficheiros (\texttt{open, close, write, read, ...}). Para isso a biblioteca \textit{libfuse} dispõe de uma estrutura do tipo \texttt{struct
fuse\_operations} que permite registar as funções de \textit{callback}. No caso da chamada \texttt{open} foi desenvolvida a função \texttt{mellon\_open} que,
a cada invocação, gera um código aleatório de 4 caractéres, com recurso à função \texttt{getentropy}:
\begin{Verbatim}
getentropy(buf, sizeof(char)*4);
\end{Verbatim}
Este código é enviado para o endereço de correio eletrónico do utilizador, recorrendo para isso à biblioteca \texttt{libcurl}.
Após o envio do mesmo, o utilizador deve introduzir o valor recebido no \textit{frontend}, que é enviado, através de um \textit{named pipe}, para o 
\textit{daemon}:
\begin{Verbatim}
if request.method == 'POST':
    code = request.form['fa_code']
    mellon_fifo.write(code[:5])
    mellon_fifo.flush()
\end{Verbatim}
O \textit{daemon}, após receber este valor, verifica se o mesmo ainda é válido(\textbf{i.e.} se foi gerado nos últimos 45s) e em caso afirmativo, verifica
se corresponde ao valor efetivamente enviado ao utilizador, autenticado o mesmo em caso de sucesso:
\begin{Verbatim}
gettimeofday(&start, NULL);
read(mellon_fifo_fd, user_code, 4);
gettimeofday(&end, NULL);

//Timeout if user takes more than 45 secs do input code
if(end.tv_sec - start.tv_sec < 45 && !strcmp(user_code, fa_code)){
\end{Verbatim}
\subsection{Utilização}

\section{Conclusão}

\end{document}
