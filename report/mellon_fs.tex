\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}
\usepackage[a4paper, total={7in, 9in}]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{fancyvrb}

\newcommand{\question}[1]{
    {\large \textbf{Q: #1}}
    \\
}

\newcommand{\titleRule}{
    \rule{\linewidth}{0.5mm} \\ [0.25cm]
}

\begin{document}

\begin{titlepage}
    \center
    \begin{figure}[H]
        \centering
        \includegraphics[width=4cm]{Pictures/UM_EENG.jpg}
    \end{figure}
    \textsc{\LARGE Universidade do Minho} \\ [1.5cm]
    \textsc{\Large Mestrado Integrado em Engenharia Informática} \\ [0.5cm]
    \textsc{\large Tecnologia de Segurança} \\ [0.5cm]

    \titleRule
    {\huge \bfseries MellonFS - Userspace Filesystem}
    \titleRule

    Miguel Miranda Quaresma A77049 \\[0.25cm]

    \today \\[5cm]
    \tableofcontents
\end{titlepage}

\newpage

\section{Introdução}
A utilização de sistemas de computação tem vindo a tornar-se um requisito cada vez mais fundamental nas mais diversas áreas da sociedade. Consequentemente, é 
necessário garantir que os mesmos representam uma plataforma de trabalho segura que não comprometa os serviços que neles dependem. Um aspetos fundamentais para 
atingir esse objetivo passa por controlar o acesso de diversos utilizadores aos ficheiros presentes nos sistemas, sendo necessário desenvolver mecanismos que 
sejam não só seguros e convenientes mas também adequados às necessidades apresentadas.
O sistema de permissões Unix apresenta portanto uma clara desvantagem: a sua simplicicade torna-o pouco flexível e difícil de gerir para um utilizador "normal". 
Para colmatar este facto torna-se útil desenvolver sistemas de ficheiros a um nível mais elevado que recorram a estruturas de controlo de acesso complexas, 
permitindo assim implementar um sistema de controlo eficaz. O presente trabalho apresenta um implementação primitiva de um mecanismo de controlo de acesso com 
recurso à biblioteca libfuse que visa autenticar utilizadores com recurso a um código aleatório.

\section{libfuse}
Como foi referido o presente projeto recorre à biblioteca \textit{libfuse} que é uma API para o módulo \textbf{FUSE} do kernel Linux que permite o 
desenvolvimento de sistemas de ficheiros em \textit{userspace}.

\section{MellonFS}
O sistema MellonFS apresenta uma arquitetura constituída por dois módulos distintos: uma \textit{web interface} responsável por autenticar o utilizador cada 
vez que este recebe um código no seu endereço de correio eletrónico e o sistema de ficheiros em si, desenvolvido em C com recurso à biblioteca libfuse, 
responsável por gerar o código de autenticação e notificar o utilizador. Cada vez que é invocada a \textit{system call} \texttt{open}, é gerado, aleatoriamente, 
um \textit{array} de 4 bytes que após ser enviado ao utilizador, deve ser introduzido pelo mesmo num período de tempo inferior a 45s para que a autenticação 
tenha sucesso.

\subsection{Implementação}
\subsubsection{Web Frontend}
O \textit{fronted} foi desenvolvida com recurso à linguagem Python e à framework \textit{Flask}.
É esta a componente que deve ser invocada para iniciar o \textit{daemon} do sistema de ficheiros e autenticar o utilizador cada vez que este pretende abrir um 
ficheiro. Antes de inicializar o \textit{daemon}, o \textit{frontend} requisita o \textit{username} ao utilizador, que permitirá determinar se este está 
autorizado a alterar ficheiros no sistema desenvolvido. De seguida este valor é passado ao \textit{daemon} como argumento de linha de comandos:
\begin{Verbatim}
args=['./bin/mellon', '../MountPoint']
...
mellon_fs = Popen(args)
\end{Verbatim}
Qualquer comunicação subsequente entre os dois processos é efetuada com recurso a um \textit{named pipe} que é aberto para escrita no \textit{frontend}:
\begin{Verbatim}
mellon_fifo = open("mellon_fifo", "w")
mellon_fifo = open("mellon_fifo", "w")
...
if request.method == 'POST':
    code = request.form['fa_code']
    mellon_fifo.write(code[:5])
    mellon_fifo.flush()
\end{Verbatim}

Este módulo foi desenvolvido com recurso à biblioteca \textit{Flask} e possui duas \textit{views} distintas: uma para identificação inicial e outra para 
autenticação \textit{on demand}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{Pictures/Main.png}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=10cm]{Pictures/Auth.png}
\end{figure}

\subsubsection{File system daemon}
O sistema de ficheiros em si foi desenvolvido em C e implementa as funções que são invocadas consoante as \textit{system calls} feitas ao sistemas 
(\texttt{open, close, write, read, ...}). Para isso a biblioteca \textit{libfuse} dispõe de uma estrutura do tipo \texttt{struct
fuse\_operations} que permite registar as funções para cada um dos casos \textit{callback}. No caso da \textit{system call} \texttt{open} foi 
desenvolvida a função \texttt{mellon\_open} que, a cada invocação, gera um código aleatório de 4 caractéres, com recurso à função \texttt{getentropy}:
\begin{Verbatim}
getentropy(buf, sizeof(char)*4);
\end{Verbatim}
Este código é enviado para o endereço de correio eletrónico do utilizador, recorrendo para isso à biblioteca \texttt{libcurl}.
Após o envio do mesmo, o utilizador deve introduzir o valor recebido no \textit{frontend}, que é enviado através de um \textit{named pipe}, para o 
\textit{daemon}:
\begin{Verbatim}
gettimeofday(&start, NULL);
read(mellon_fifo_fd, user_code, 4);
gettimeofday(&end, NULL);

//Timeout if user takes more than 45 secs do input code
if(end.tv_sec - start.tv_sec < 45 && !strcmp(user_code, fa_code))
\end{Verbatim}
Para ser autenticado com sucesso, o valor introduzido pelo utilizador deve cumprir os seguintes requisitos:
\begin{itemize}
    \item foi gerado nos últimos 45s
    \item corresponde ao valor efetivamente enviado ao utilizador (\texttt{fa\_code})
\end{itemize}

O mecanismo de autenticação envolve ainda uma verificação prévia que visa garantir que o utilizador 
tem permissão para aceder ao sistema de ficheiros, sendo que o conjunto de utilizadores nestas condições
se encontram armazenados no ficheiro \texttt{mellon\_acl.enc}.
Para garantir a confidencialidade desta informação, e que a mesma apenas pode ser alterada por quem tem autorização,
o ficheiro encontra-se cifrado com recurso à cifra AES em modo CBC com recurso à ferramenta OpenSSL:
\begin{Verbatim}
    #define DEC "openssl enc -aes-256-cbc -in %s.enc -out %s.txt -K %s -iv %s -d"
    #define ENC "openssl enc -aes-256-cbc -in %s.txt -out %s.enc -K %s -iv %s && rm %s.txt"
\end{Verbatim}
Cada vez que o \textit{daemon} é iniciado, este ficheiro é temporariamente decifrado e, após o utilizador ter sido (ou não)
autenticado, este é atualizado, com ecurso à função:
\begin{Verbatim}
int encrypt_decrypt(char *source, int enc_dec)
\end{Verbatim}

\subsection{Utilização}
A página inicial da aplicação inclui uma breve descrição da mesma.
\section{Conclusão}

\end{document}
